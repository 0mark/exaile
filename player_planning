
devices we want to support: (see per-device section FMI)
    ipods (via python-gpod)
    mtp devices (via pymtp)
    mass storage (no library needed)
    audio cds (no library needed to play, pycddb for metadata)
    mp3 cds (no library needed)
    SACDs? 
    audio dvds? 
    mp3 dvds? (do these even exist?)
    DAAP shares (via python-daap and python-avahi)
    UPnP shares?

device recognition/persistence:
    are there flags in HAL that are 100% guaranteed to recognize players?
        we can definitely do this for ipod, idk about mtp/mass
        if info.capabilities contains portable_audio_player we know it is
            hal-info defines around 60 player classes this way
            libmtp defines 130+ players
            devices not caught this way can be manually added in the 
                device manager, though we should file bugs against hal-info
                and/or libmtp for them
        the portable_audio_player.* keys have some info on the capabilities of
            players. while these are not definitive, they are likely good 
            enough to handle the majority of circumstances. keys of interest:
            access_method.protocols 
                values: storage, ipod, mtp
            output_formats 
                values: 'audio/aac', 'audio/x-ms-wma', 'audio/x-wav', 'audio/audible', 'application/ogg', 'video/x-ms-asf', 'audio/flac', 'audio/x-ms-asf', 'audio/ogg', 'audio/vnd.sony.atrac3', 'audio/amr', 'audio/3gpp', 'audio/mp4', 'audio/vnd.rn-realaudio', 'audio/x-amr', 'audio/x-imy', 'audio/x-midi', 'audio/AMR', 'audio/amr-wb', 'audio/vnd.m-realaudio', 'audio/x-m4b', 'audio/midi', 'video/x-smv', 'audio/mpeg'
                relevant mappings:
                    aac - 'audio/aac', 'audio/mp4'
                    flac - 'audio/flac'
                    mp3 - 'audio/mpeg'
                    ogg - 'application/ogg', 'audio/ogg'
                    wav - 'audio/x-wav'
                    wma - 'audio/x-ms-wma'
            input_formats
                values: 'audio/x-wav', 'audio/mpeg', 'audio/x-ms-wma', 'audio/amr', 'audio/x-amr', 'audio/aac', 'audio/AMR', 'audio/midi'
                this is what formats the device can record to. probably not 
                    useful to us.
            playlist_path
                values: 'PLAYLISTS/%File', 'Playlists/', 'MUSIC/AllMyMusic.m3u', 'PLAYLIST/%File', 'Playlist/', 'Music/playlists', 'Playlists/%File'
                I -think- this is for defining the playlist containing the song order on devices that don't do tag or path browsing, but im not sure.
            playlist_format
                values: 'audio/x-mpegurl', 'audio/x-scpls', 'application/vnd.ms-wpl', 'audio/x-iriver-pla'
                not very informative, only defined for 16 player classes
                probably goes with playlist_path
            audio_folders
    require user to explicitly connect to a device the first time, but after that
        attempt to auto-connect
        - we could use filesystem UUIDs to recognize players with 100% accuracy
        - if there's a HAL key that would work instead that may be better
            storage.serial?
        - is there a non-HAL way to detect when new fses are mounted?
            - best solution thus far: don't try to auto-detect, just poll
                mtab and libmtp when the device manager is open and require
                users to manually connect through the device manager

transfer&syncing:
    drag and drop from collection to device or vv. should work perfectly
    allow sending an enitre playlist to the device (from tab, playlist manager 
        or file). this should also ensure that all tracks in the playlist also
        are transferred to the device
    cover art should be synced if possible
    calculate the space needed for the transfer before we begin, and tell the 
        user if there's not enough space to complete the operation
        - offer possible ways of resolving the issue? eg remove old podcasts, 
            songs, reencode to a lower bitrate, etc? 
            - may be slightly overkill
    allow transcoding on transfer
        by default, transcode only if not in a supported format
        also allow transcoding by bitrate thresholds (eg >128kbps)
            - allow transcode of VBR mp3 to CBR option? may be difficult, but 
                could be quite useful for some cheap or old players.

playlists:
    subclass playlist manager or something else?
    if done right we can also just subclass the ui's playlist manager to keep 
        everything really simple

podcasts:
    ????? (podcasts not yet implemented in trunk)
    auto-delete old? (by date thresh? count thresh? played/not?)
    should we download podcasts on sync if not downloaded, or skip
        them until they are ready?
        - if manual download, download on sync (but dont block other transfers)
        - if auto download, prioritize in download queue
    allow user to choose what podcasts to auto-sync

playing:
    allow playing right off the device
    dont use the stupid device URI schema introduced in 0.2. instead, just use 
        full filesystem paths and the COLLECTIONS set (with library path 
        regonition) to find where a track comes from.
    hide tracks that are DRM-encypted as we can't play them (can we recognize 
        this?)

display:
    device manager:
        show all configured devices, allow connection/disconnection
        add dialog will show detected devices
        - hal's storage.icon.[drive|volume] keys could be used for the icon column
        also exposes any possible prefs for that device
            path to music location (default: root/music)
            path to podcast location (default: root/podcasts)
            path to playlists location (default: root/playlists)
            music subpaths (default: artist/album/num - title.ext)
            supported file formats (default: from plugin)
            playlist format to use (default: m3u)
            transcode threshold (default: disabled)
            transcode format(s) (default: from plugin) 
            name to use for the device (default: auto-detect)
            whether to auto-connect when available (default: no)
            - plugins can set which of these are visible and change the defaults
    panel:
        show remaining space at bottom of the panel
            also show battery status if possible
            Battery:        xx% 
            Space used:     xx%
        how should we expose playlists/podcasts?
            0.2 method: they just appear as extra entries on top of the tree
                pros: simple, easily seen
                cons: inconsistent with main UI, interferes with using the tree,
                    doesn't handle podcasts
            alternative: add a new combo box at the top to select the view
                pros: simple, clean separation, easily extensible, allows reuse
                    of panel code from the rest of exaile
                cons: less obvious, takes up some space
        transfer queue:
            show as simple button at bottom 
                [xx songs to transfer] [start]
            clicking on the [xx ...] will open the list as a new tab in the 
                playlist area that can be edited
            alternatively, the transfer queue could be exposed as another view 
                of the device panel as outlined above for playlists/podcasts
                this is likely both cleaner and easier. in this case clicking
                the [xx...] will switch to the queue view.
            while transferring the progressbar will appear below all panels, 
                just as the rescan collection and other tasks do
            queue should be editable while transferring, at least for append
        info panel:
            another entry in the drop-down with playlists/queue/etc, displays
                stuff like device name, model, version, vendor name, device
                type, detailed battery/space information.
                - libmtp has built-in support for getting this info, other
                    devices will have to rely on HAL

per-device considerations:
    mp3 players:
        ipod:
            supported formats: mp3, aac, alac
        mtp:
            supported formats: varies, usually mp3 and wma
        mass:
            supported formats: varies, usually mp3 and wma
        devices that can have multiple mount points (eg those with expansion
            slots for flash memory) need to be merged smoothly.
            - merge in main tree, playlists
            - show one transfer queue per mount point
            - can we detect these situations via HAL?
                storage.originating_device?
            - when transferring songs due to a playlist/podcast, try to put 
                them all on the same device
    optical media:
        cds:
            audio:
                musicbrainz tag-finding support? (submission?)
                can burning be sensibly exposed via the same transfer method?
            mp3:
                how to distinguish from data cd
                view as one large playlist by default, but allow a tree view
                burning?
            SACD:
                need to get one for testing first
        dvds:
            audio:
                need to get one for testing first
            mp3:
                do these exist? we can support them anyway I guess since they'd
                    essentially be mp3 cds with a different HAL signature and more
                    capacity
    network:
        daap:
            python-daap is currently limited to version 6 of the protocol, is 
                there anything that supports 7?
                - may not be feasable, as v7 uses certificate authentication
        upnp:
            need to find bindings
            python-coherence?
            - rhythmbox has a upnp plugin based on coherence we can use as 
                an example


what this should all look like to the user:
    cd (and similar) media: 
        user inserts disk
        a new tab in exaile appears for the disk, automatically listing
            all the tacks and retrieving metadata
    devices (eg ipod):
        user plugs in device
        a new tab appears with the name of the device
        the user clicks the connect button in this tab to connect to the
            device, retrieving the track listing and playlists
    network shares:
        user opens the device manager
        detected shares are displayed along with other devices
        user selects share to connect to and presses "Connect"
        a new tab appears with the name of the share. the track listing and
            any other info is displayed

    manual:
        user opens the device manager        
        user clicks "Add" button
        user selects the type of device to connect to, a list of detected
            devices is displayed, along with an option to manually specify
            the device location
        user selects a share and presses OK
        a new tab appears with the name of the share. the track listing and
            any other info is displayed


rockbox:
    detect whether rockbox is installed and adjust appropriately
    update rb db in-place?
        - use rb lib? (may be difficult, as we can't embed C)
        - reimplement lib? (more portable but will need constant maintenance)
            - db is supposed to be really simple (because some devices dont 
                have much power), so should be possible
            - may have to take endianness issues into account


code planning:
    Device class:
        .collection - collection object for all tracks on the device
        .playlists - playlists manager for playlists on the device
        .connect() - connect to the device, load tracks/playlists
        .disconnect() - safely disconnect from the device

