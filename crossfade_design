

Old System:

    +-----------------------------------------------------------+
    | Playbin                                                   |
    |                       +-------------------------------+   |
    |                       | Sinkbin                       |   |
    | (deep black magic)----| - everything we do custom     |   |
    |                       | - [alsa|pulse|oss]sink        |   |
    |                       +-------------------------------+   |
    |                                                           |
    +-----------------------------------------------------------+


Unified System:

                +-------+       
    Stream1 ----|       |
                | Adder |
    Stream2 ----|       |
                +-------+
                    |
                  Queue
                    |
              Postprocessing
                    |
                +-------+
                |       |---- FakeSink
                |       |
                |       |---- AudioSink
                |  Tee  |
                |       |---- VisualizationSink
                |       |
                |       |---- <other sinks>
                +-------+




Stream:
    A source for music. There will be exactly two of these, which will be
        switched between whenever the track changes.
    Contains:
        uridecodebin
        selector? (in case there are multiple streams)
        audioconvert?
        <custom elements from plugins>
        volume control (for fading, should be 100% normally)

Queue:
    Needed so that playback is smooth when swapping streams.
    Contains:
        queue

Postprocessing:
    Contains:
        <custom elements from plugins>

FakeSink:
    Needed so that the pipeline is never incomplete, even when hot-swapping
        AudioSinks
        - maybe we could just use fakesink's handoff option to pass data
            to the actual sink?
    Contains:
        fakesink sync=true (sync is needed so it doesnt run too quickly
            when there are no other sinks to keep it in check.)

AudioSink:
    Contains:
        <custom elements from plugins>
        any processing needed right before the sink
        [alsa|pulse|oss|oss4|esd|auto|gconf|halaudio|...]sink

VisualizationSink:
    Contains:
        the visualization plugin

How it works:
    Gapless:
        uridecodebin fires a "drained" signal when it runs out of data.
        When we get this signal, we set up the next stream and connect it to 
            the music adder. The queue immediately after the adder will give
            the new stream time to preroll and ensures a perfect transition.

    Crossfading:
        We set a timer to wake up x seconds before the current stream ends.
        When the timer wakes up, it sets up the new stream and adds another
            timer to do the fading.
        When the fading is done, teardown the first stream.

    Visualizations:
        We just create the visualization element and add it to tee. Tee
            should let us do this without disrupting the stream at all.
            - this makes adding new visualization backends REALLY easy, as
                long as there's already a gstreamer element for it.

    Switching audio sinks:
        Make the new sink, add it to tee and remove the old. Just as
            with visualizations tee should let us do this seamlessly.
            - many sinks prevent any other kinds of sink from accessing
                the device, so maybe we need to remove the current before
                adding a new one.

    Streaming to icecast/etc:
        Just add the sink to tee. It can be done midstream even. The normal 
            sink can be run in parallel.
        (icecast specifically can be done with shout2send, which expects
            an input stream in either ogg or mpg[13] format so we'll 
            have to add an encoder to the pipeline)

Plugin interface:
    plugins are able to
        - add new sinks 
        - add elements to streams
        - add elements to postprocessing
        - add elements to sinks

Misc Notes:
    this setup precludes video playback support (as we can't mix video
        streams), though there's no reason we couldn't just make another
        player for video support if we want to add it. Alternatively,
        video playback could just force gapless mode and then
        do some voodoo to capture the video from the current Stream.

Communication with most elements will take place through providers and settings.

Providers:
    stream_element - provides a gst element to add to all streams and an index
        for the element. the index is used to determine relative ordering of 
        elements.
    postprocessing_element - same as stream_element
    sink_element - same as stream_element. Sinks are not required to implement
        support for these. (alsa/oss/pulse/esd/hal/auto/gconf all will)
    sink_method - provides an AudioSink and a name for it. May also expose
        configuration methods.
    visualization_method - provides a VisualizationSink and a name for it.
        May also expose configuration methods.

Settings:
    the following elements are controlled purely by settings:
        equalizer
            equalizer/band-*
        replaygain
            replaygain/album-mode
            replaygain/pre-amp
            replaygain/fallback-gain
        volume
            player/volume

