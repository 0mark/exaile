

Current System:

    +-----------------------------------------------------------+
    | Playbin                                                   |
    |                       +-------------------------------+   |
    |                       | Sinkbin                       |   |
    | (deep black magic)----| - everything we do custom     |   |
    |                       | - [alsa|pulse|oss]sink        |   |
    |                       +-------------------------------+   |
    |                                                           |
    +-----------------------------------------------------------+


New System:

                +-------+                       +-------+
    Stream1 ----|       |                       |       |---- AudioSink
                |       |                       |       |
    Stream2 ----| Adder |----Postprocessing ----|  Tee  |---- AudioSink
                |       |                       |       |
    Stream3 ----|       |                       |       |---- VisualizationSink
                +-------+                       +-------+


Sadly we can't use playbin, as two playbins can't share an element for
    their sink. However decodebin will take care of most of playbin's
    work for us.

Stream:
    Contains:
        [filesrc|cdparanoiasrc|neonhttpsrc]
        [queue|] (only enabled on remote streams)
        decodebin2 
        selector? (in case there are multiple streams)
        audioconvert?
        audioresample?
        rgvolume (this way each stream automatically gets the right RG)
        rglimiter
        <custom elements from plugins>
        queue (for buffering)
        volume control (for fading, should be 100% normally)

    streams which are not playing should be disconnected and have their src
        pads blocked

    there will be a persistent "silence" stream to avoid some potential issues
        - audiotestsrc wave=4
        - so as to play nice, we should release the sink after x seconds
            if there are no active streams. That way exaile doesn't lock the
            sound device to whatever audio sink its using.

Adder:
    Contains:
        adder (duh)


Postprocessing:
    Contains:
        equalizer
        <custom elements from plugins>

Tee:
    Contains:
        tee (duh)

AudioSink:
    Contains:
        volume control
        <custom elements from plugins>
        alsasink/pulsesink/etc
        any processing needed right before the sink

Visualization:
    Contains:
        the visualization plugin

How it works:
    Gapless:
        decodebin2 fires a "drained" signal when it runs out of data.
        When we get this signal, we should setup the next stream and
            let it preroll, but not playing or linked to the adder.
        When the queue for the first stream sends the "underrun" signal,
            connect the next stream and set it to playing, then disconnect
            the current stream
            - we should ensure the queue always stores enough data to handle
                this smoothly, a few (5?) seconds should be sufficient for
                even very slow srcs. This could perhaps be configurable in
                the advanced settings editor.

    Crossfading:
        Same as gapless, except
            - we set the queue size to be <fade duration> seconds bigger
            - when we get the drained signal, we set a timer to start us
                fading at the right time
            - we connect the second stream when we start fading, but 
                disconnecting the current stream still happens on "underrun"

    Visualizations:
        We just create the visualization element and add it to tee. Tee
            should let us do this without disrupting the stream at all.
            - this makes adding new visualization backends REALLY easy, as
                long as there's already a gstreamer element for it.

    Switching audio sinks:
        Make the new sink, add it to tee and remove the old. Just as
            with visualizations tee should let us do this seamlessly.

    Streaming to icecast/etc:
        Just add the sink to tee. It can be done midstream even. The normal 
            sink can be run in parallel.

        (icecast specifically can be done with shout2send, which expects
            an input stream in either ogg or mpg[13] format so we'll 
            have to add an encoder to the pipeline)

Plugin interface:
    plugins will be able to
        - add new streams
        - add new sinks 
        - add elements to streams
        - add elements to postprocessing
        - add elements to sinks

Things to watch out for:
    - seek/pause after the new stream has begun prerolling/fading
    - next stream being bad/missing
    - method for selecting order when plugins add elements

Misc Notes:
    this setup precludes video playback support (as we can't mix video
        streams), though there's no reason we couldn't just make another
        player for video support if we want to add it. Alternatively,
        video playback could just force crossfade duration to 0 and then
        do some voodoo to capture the video from the current Stream.

    during this rewrite might be a good time to implement CUE support
        (at least the player side of it), as we have to revisit most of this
        anyway. 


Useful Info:
    the RB patch for crossfading (good comments!): 
            http://bugzilla.gnome.org/attachment.cgi?id=85250


Code Design:
    Player:
        set_queue(queue)
        set_volume(vol)
        get_volume()
        get_state()
        is_playing()
        is_paused()
        get_position()
        get_time()
        get_progress()
        play(track)
        stop()
        pause()
        unpause()
        toggle_pause()
        seek(value)

        add_sink(sink)
        remove_sink(sink)
        add_stream(stream)
        remove_stream(stream)
        <incomplete?>
    Stream:
        set_track(track)
        set_volume(vol)
        <methods needed for playback control>
        <incomplete?>
    Postprocessor:
        <no public methods>
    AudioSink:
        set_volume(vol)
        <other options vary by sink>
    VisualizationSink:
        set_visualizer(visualizer)
        <visualizers may provide other methods>

Communication with most elements will take place through providers and settings.

Providers:
    stream_element - provides a gst element to add to all streams and an index
        for the element. the index is used to determine relative ordering of 
        elements.
    postprocessing_element - same as stream_element
    sink_element - same as stream_element. Sinks are not required to implement
        support for these. (alsa/oss/pulse/esd/hal/auto/gconf all will)
    sink_method - provides an AudioSink and a name for it. May also expose
        configuration methods.
    visualization_method - provides a VisualizationSink and a name for it.
        May also expose configuration methods.

Settings:
    the following elements are controlled purely by settings:
        equalizer
            player/equalizer
            equalizer/band-*
        replaygain
            player/replaygain
            replaygain/album_mode
            replaygain/preamp
            replaygain/fallback
        volume
            player/volume



