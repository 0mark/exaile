

Current System:

    +-----------------------------------------------------------+
    | Playbin                                                   |
    |                       +-------------------------------+   |
    |                       | Sinkbin                       |   |
    | (deep black magic)----| - everything we do custom     |   |
    |                       | - [alsa|pulse|oss]sink        |   |
    |                       +-------------------------------+   |
    |                                                           |
    +-----------------------------------------------------------+


New System:

                +-------+                       +-------+
    Stream1 ----|       |                       |       |---- AudioSink
                |       |                       |       |
    Stream2 ----| Adder |----Postprocessing ----|  Tee  |---- AudioSink
                |       |                       |       |
    Stream3 ----|       |                       |       |---- VisualizationSink
                +-------+                       +-------+


Sadly we can't use playbin, as two playbins can't share an element for
    their sink. However decodebin will take care of most of playbin's
    work for us.

Stream:
    Contains:
        uridecodebin
        selector? (in case there are multiple streams)
        queue (for buffering)
        audioconvert?
        audioresample?
        replaygain (this way each stream automatically gets the right RG)
        volume control (for fading, should be 100% normally)

    RB uses "src [ ! queue ] ! decodebin ! audioconvert ! audioresample ! caps ! queue ! volume"
        - the first queue is only enabled on non-local streams.    

    RB also has a persistent "silence" stream - lets the sink start w/o an 
        active stream and prevents potential transition problems.

    In RB streams are only connected if they're actually playing not paused 
        or prerolling. When not connected their src pad is blocked.

Adder:
    Contains:
        adder (duh)


Postprocessing:
    Contains:
        equalizer

Tee:
    Contains:
        tee (duh)

AudioSink:
    Contains:
        volume control
        alsasink/pulsesink/etc
        any processing needed right before the sink

Visualization:
    Contains:
        the visualization plugin

How it works:
    Crossfading:
        When we start a stream, we set a timer to wake up when the 
            stream is close to ending. (if the user seeks/pauses we 
            reset the timer appropriately)
        When the timer wakes up, it sets up a new stream and starts 
            it fading in while fading out the other. We should
            probably wake up slightly before we need to to give the 
            stream time to preroll.

    Visualizations:
        We just create the visualization element and add it to tee. Tee
            should let us do this without disrupting the stream at all.
        - this makes adding new visualization backends REALLY easy, as
            long as there's already a gstreamer element for it.

    Switching audio sinks:
        Make the new sink, add it to tee and remove the old. Just as
            with visualizations tee should let us do this seamlessly.

    Streaming to icecast/etc:
        Just add the sink to tee. It can be done midstream even. The normal 
            sink can be run in parallel.

        (icecast specifically can be done with shout2send, which expects
            an input stream in either ogg or mpg[13] format so we'll 
            have to add an encoder to the pipeline)

Plugin interface:
    plugins will be able to
        - add new streams
        - add new sinks 
        - add elements to streams
        - add elements to postprocessing

Things to watch out for:
    - seek/pause after the new stream has begun prerolling/fading
    - next stream being bad/missing
    - method for selecting order when plugins add elements

Misc Notes:
    this setup precludes video playback support (as we can't mix video
        streams), though there's no reason we couldn't just make another
        player for video support if we want to add it. Alternatively,
        video playback could just force crossfade duration to 0 and then
        do some voodoo to capture the video from the current Stream.

    during this rewrite might be a good time to implement CUE support
        (at least the player side of it), as we have to revisit most of this
        anyway. 



Useful Info:
    the RB patch for crossfading (good comments!): 
            http://bugzilla.gnome.org/attachment.cgi?id=85250



Code Design:
    Player:
        set_queue(queue)
        set_volume(vol)
        get_volume()
        get_state()
        is_playing()
        is_paused()
        get_position()
        get_time()
        get_progress()
        play(track)
        stop()
        pause()
        unpause()
        toggle_pause()
        seek(value)

        add_sink(sink)
        remove_sink(sink)
        add_stream(stream)
        remove_stream(stream)
        <incomplete?>
    Stream:
        set_track(track)
        set_volume(vol)
        <methods needed for playback control>
        <incomplete?>
    Postprocessor:
        <no public methods>
    AudioSink:
        set_volume(vol)
        <other options vary by sink>
    VisualizationSink:
        set_visualizer(visualizer)
        <visualizers may provide other methods>

Communication with most elements will take place through providers and settings.

Providers:
    stream_element - provides a gst element to add to all streams and an index
        for the element. the index is used to determine relative ordering of 
        elements.
    postprocessing_element - same as stream_element
    sink_element - same as stream_element. Sinks are not required to implement
        support for these. (alsa/oss/pulse/esd/hal/auto/gconf all will)
    sink_method - provides an AudioSink and a name for it. May also expose
        configuration methods.
    visualization_method - provides a VisualizationSink and a name for it.
        May also expose configuration methods.

Settings:
    the following elements are controlled purely by settings:
        equalizer
            player/equalizer
            equalizer/band-*
        replaygain
            player/replaygain
            replaygain/album_mode
            replaygain/preamp
            replaygain/fallback
        volume
            player/volume



