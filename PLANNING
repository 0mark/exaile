This is for notes and plans regarding exaile 0.3. 
It should also be used to keep track of what each contributor is
currently working on.

Current projects:
    Aren Olson - Persistence
    Adam Olsen - GUI
    Anthony Waters - 
    thiblahute - CD Burning

*** QUICK NOTE:  We need to make a way that coders can easily see what 
object export which events, and possibly have a way for this to show up 
in epydoc
**** I think perhaps adding an "Events" section to the docstring for each 
class would be the way to go here. something like:

class TrackDB:
    """
        blah blah blah...

        Events:
            track_added - sent when a track is added to the db
                data: the loc of the track
            track_removed - sent when a track is removed from the db
                data: the loc of the track
    """

this doesn't handle the case where multiple classes emit the same event
though, though I do not know of any cases of that in the current codebase
(except those arising from subclassing which don't count)

Implemented:
    Collection
    Libraries
        now has realtime watching!
    Playlists
        random, repeat
        import/export for m3u/pls/asx/xspf
    Player
    Queue
    Settings
    Event
        signals-like system
    XDG
        exaile's config and data files now stored according to xdg spec
    Logging System
    Smart Playlists
    CD Playback
        doesn't support mp3 CDs yet
    Track Syncronization
        very prelimiary, will need careful watching
    Device Manager
        only for cd right now
    HAL Support
        only for cd right now
    Playlists Manager
        manages persistence of playlists and smart playlists.
    Plugins System
        file format: tar archive (optionally with gzip/bzip2), gets extracted
                into XDG_DATA_HOME, loads from there or XDG_DATA_DIRS
        does not yet allow retrieval from remote server (has stubs)
    Covers
        todo: support embedded covers, cover from filename via tag 
            info (eg. %artist-%album.jpg)
    Internet Radio
        not at all feature-complete
    Lyrics Manager
    Dynamic Playlists
    MMKeys
        Only for gnome >= 2.20
    Gapless Playback
        limitation: the UI will see the track as changing when the next track
            is 'spooled up', rather than when the change happens. This is a 
            limitation of the current playbin2. In most cases the difference
            should be negligible.
    Equalizer
    Replaygain
    CD Ripping

Things that can probably be implemented at this stage:
    CD Burning
        class in cd.py, takes a Playlist and burns it in order
        allow mp3 cd burning
    Content-Matching (involved)
        matching tracks based on tag content rather than loc.
        useful for: detecting moves withing the library, xspf playlists
        ?match by everything or a subset? if x% is the same? efficiency?
        needed? see alternate DB ideas below
    DBUS
    Podcasts
        part of radio or separate?
        allow flexibility in choice of when (if?) and where to download
        allow streaming if not downloaded
    MP3 Player Support
        will likely need some additional work in devices and hal
        generic classes subclassable for iPod, MTP and MassStorage players
        support for each type of player implemented as a plugin
        create a special Collection for each, load Playlists, etc.
        also should handle transfer, nto necessariliy at first
            transcode on transfer also good
                auto-detect supported formats (allow choosing too)
                transcode only if
                    not in specified format
                    above certain bitrate/filesize?
            algorithms to handle sync?
            allow custom file layout if applicable
        podcast support
            limit number / autodelete old ?
        found on ubuntu forums: "With amarok I can grab a playlist, drag 
            it to my player and Amarok will automatically 
            transfer all the associated songs and generate the playlist 
            on my player. No other app was able to do this." - this is a GOOD 
            IDEA, we should aim for this sort of "Just Works" wherever possible
    Persistence 
        everything should be persistent, ie. when opening exaile it should appear 
            EXACTLY as it was when you exited.
        todo list:
            make queue, player persistent
            optimize saving mechanisms to prevent unneeded disk I/O
                done for smart playlists 
                needs doing for general trackdb
                    use track events to know when contained are updated
            ensure all commits to essential data are crash-proof
                save to <file>.new
                move <file> to <file>.old
                move <file>.new to <file>
                delete <file>.old
                make restore able to cope with the outcome of interruption
                    at any of these steps
            periodic save to disk so that in event of crash eveything is saved
            how to deal with streams or devices, which cannot be guaranteed
                to be present upon resume?
    GUI
        should not be drastically different from 0.2
        separate classes (with associated glade files) for each part
            side panes
            playlist panel
            now playing area
            info tabs
            ???
        use gtk.glade.XML.signal_autoconnect *whenever* possible... this
            is something we didn't do in 0.2 and it was a pain
        devices:
            idea: use separate side tab for each device, with device manager
                option in Tools for advanced config. tabs would be
                auto-generated as new devices are connected, either via HAL
                or the device manager. 
    Visualizations
        implement as plugin (if possible)
    Cross-Fade
        use gst's adder element to combine streams
        use peek() methods on playlists and queue to see next track
            without actually switching to it.

Minor Tasks:
    make hal non-mandatory
    add comments and docstrings in xl/player.py
    implement buffering handling in xl/player.py (see gstreamer playbin docs)
    handle devices other than /dev/cdrom for disc in xl/player.py
    store current sort field in xl.playlist.Playlist, use this in the GUI

Other Work-Items:
    Conversion
        we need to handle the upgrade process from 0.2->0.3 smoothly
        this should include the collection, settings, plugins,
            playlists, and anything else still relevant in 0.3
        should be the last primary 'feature' implemented
        implement as plugin? that way it can just be unloaded afterwards
            saving a little bit of time and memory.

Misc:
    RAM use on large (>10000) collections? Can we get near-constant RAM use
        like banshee et al manage? On further inspection, banshee is not using 
        constant RAM, rather it is using less than 2kb per track, while 0.3 is 
        currently slightly above 4kb per track. This is still an issue, but 
        less so than before.

    possible solution: an alternate db system based on dbhash
        so we can have lower, near-constant, mem use, but use more disk i/o
        could also potentially speed up search (== will be blazing fast)
    implementation notes:
        one db to store the tracks in (index by a number)
        one db per tag for searching (index lowercase of tag)
        other things to consider: playlists 

    may require more-radical change than I was anticipating, I'm putting
    this on hold for now. work on hardening/optmizing pickledb instead


    another idea: have two DBs, one on-disk and one in-mem, with the in-mem
    db holding only what is needed to display the UI. 
        advantages: fast UI, low ram use
        disadvantages: increased disk-I/O (though less than above)
        possible issues: syncronization, searching
            search displayed cols be default, read from disk db if tag not
                in mem is specified. if you keep the separate index DBs as 
                suggested above the difference should be negligible.

==== NOTES ====
xl is to be split into xl and xlgui. All code concerning the display of 
data and receipt of user input through the gui should go into xlgui. code 
that is not dependent upon the gui implementation should go in xl.

all pluggable backends should have all backends implemented as plugins 
unless there is a really good reason to do otherwise. we will ship and 
enable some plugins by default to provide the best out-of-the-box 
experience.

idea: plugin method allowing it to determine whether it is appropriate to
    enable itself on first run, eg. enable gnomemmkeys only if under gnome.

plugins to enable by default: 
    all mmkeys plugins
    all lyrics plugins
    all covers plugins
    all dynamic plugins
    all radio plugins

plugins to ship but not enable:
    audioscrobbler - reason: if user doesnt have a lastfm account, useless
            OTOH, should be enlabled if lastfm info was set in 0.2

plugins not to ship:
    helloworld - reason: example plugin not useful to end-user
    any plugin demonstrating regular instability

=== Contributors ===
list other contributors to 0.3 here so they may be given due credit

AlphaCluster - playlist export for m3u/pls/asx/xspf
